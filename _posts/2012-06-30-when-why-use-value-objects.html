---
layout: posts
title: when and why to use Value Objects
description: Taking a look at when and why to use Value Objects
author: Charles Sprayberry
published: true

disqus_enabled: true
disqus_shortname: ramblingsofaphpenthusiast
disqus_identifier: /2012/06/30-when-why-use-value-objects.html
disqus_url: http://cspray.github.com/2012/06/30/when-why-use-value-objects
---

<h2>when and why to use Value Objects</h2>

<p>Recently I've dived back into <a href="http://www.github.com/cspray/SprayFire">SprayFire</a> and one of the things that I have been working on is making use of <a href="http://martinfowler.com/bliki/ValueObject.html">Value Objects</a>.  I have given some thought to when should I use a Value Object and when should I just use an associative array.  After all, PHP is not a purely object-oriented language, there are many paths to your destination, and arrays in PHP are extremely powerful and useful.  But, then again, so are objects.  When should you use a value object over an array?  <i>Why</i> should you use a Value Objects?</p>

<h3>when to use value objects over arrays</h3>

<p>The true answer, like most subjective things in software development, boils down to proper analysis of your application and making good decisions based on that analysis.  There is no single, this is the right way 100% of the time, answer.  Do what is best for you and makes sense.</p>

<p>Going beyond that though there are guidelines that I use to help me make that decision.  The first guideline is to <b>remember the power of arrays in PHP</b>.  There's all kinds of cool things that you can do with <a href="http://php.net/manual/en/ref.array.php">array functions</a> that objects don't easily allow.  Also remember that arrays are less resource intensive then objects.  If you're planning on creating a large number of items then arrays might be the better choice.</p>

<p>After I've reasoned that in common use cases the potential Value Object wouldn't need any of those array functions then I look to see if it is a confined, limited and/or known set of key/value pairs that I'll be working with.  I think a big part of the value, pun intended, with Value Objects is that they are more <i>expressive</i>.  This expressiveness means that a Value Object should represent a distinct set of data, that your average developer can deduce simply by look at the name of the object.  If the data in the array is widely dynamic or a numerically indexed list of data then obviously this doesn't make it easy to keep our set of data relational.</p>

<p>A great example of when to use a Value Object would be a data source login.  Perhaps something like...</p>

{% highlight php %}
<?php

class DataAccessCredentials {

    protected $user;
    protected $password;
    protected $server;
    protected $sourceName;
    protected $port;

    public function __construct($user, $password, $server = 'localhost', $sourceName = '', $port = 80) {
        $this->user = (string) $user;
        $this->password = (string) $password;
        $this->server = (string) $server;
        $this->sourceName = (string) $sourceName;
        $this->port = (int) $port;
    }

    public function getUser() {
        return $this->user;
    }

    public function getPassword() {
        return $this->password;
    }

    public function getServer() {
        return $this->server;
    }

    public function getSourceName() {
        return $this->sourceName;
    }

    public function getPort() {
        return $this->port;
    }

    public function equals($Credentials) {
        if (!($Credentials instanceof $this)) {
            return false;
        }

        // compare fields here to determine equality
    }

}
?>
{% endhighlight %}

<p>This implementation has a couple things going for it.  It is immutable, once the object is constructed there's no changing the values.  The object supplies a method to check equality, allowing us to compare two Value Objects the way they should be compared.  Finally, the data belongs together.  All of those properties are perfectly reasonable to be a part of this object and relate to one another.</p>

<p>On the opposite end of that, something like a result set from a call to the data access object using those credentials should probably be returned as an array.  The results are likely to be varied, highly dynamic and quite possibly very large.  All these things definitely make the array way more attractive.</p>

<h3>why you should use Value Objects</h3>

<div class="value-object-pro">
    <p><b>Expressiveness and Type Hinting</b></p>
    <p>Obviously one of the biggest pros to a Value Object is the parameter type hinting that is now allowed and the expressiveness of your code.  It is far more clear, or can be if you have good naming practices, what a Value Object is as compared to an array, again, particularly in type hints.</p>
</div>

<div class="value-object-pro">
    <p><b>Cleaner code, fewer errors</b></p>
    <p>The Value Object is an abstraction.  One that allows us to supply a needed value, or at the very least a default one.  We don't need to run any isset checks or any boilerplate array checking, all that's taken care of for us.  Just take a look at the two example constructors below; one with an array and one with a Value Object.</p>

{% highlight php %}
<?php

public function __construct(array $credentials) {
    $this->server = isset($credentials['server']) ? $credentials['server'] : 'localhost';
    $this->user = isset($credentials['user']) ? $credentials['users'] : 'root';
    $this->password = isset($credentials['password']) ? $credentials['password'] : '';
    $this->sourceName = isset($credentials['sourceName']) ? $credentials['sourceName'] : '';
    $this->port = isset($credentials['port']) ? $credentials['port'] : 80;
}

public function __construct(DataAccessCredentials $credentials) {
    $this->server = $credentials->getServer();
    $this->user = $credentials->getUser();
    $this->password = $credentials->getPassword();
    $this->sourceName = $credentials->getSourceName();
    $this->port = $credentials->getPort();
}

?>
{% endhighlight %}

<p>I don't know about you, but I know which one I'd rather come across in calling code and
it isn't the one accepting an array.</p>
</div>

<div class="value-object-pro">
    <p><b>Immutability</b></p>
    <p>For me this is a really big win.  The immutability of objects is very important to me.  When I'm storing certain sets of data that could be used in a Value Object I probably don't want that data to be manipulated.  A good way to attain this immutability is to simply provide no setters to protected/private properties and only accept the values in the <code>__construct()</code> of the object.  This ensures that every time we call on a value we're sure it is going to be the one we expect.  With arrays there is simply no assurance of this immutability.</p>
</div>

<h3>wrapping it all up</h3>

<p>I use an array when:</p>

<ul>
    <li>The data set is varied or widely dynamic.</li>
    <li>Use cases involve using those array functions.</li>
    <li>Creating a lot of value sets and don't want to take an object creation hit.</li>
</ul>

<p>I'll use an object when:</p>

<ul>
    <li>Data set is confined and relational to one another.</li>
    <li>Probably won't need to use array functions.</li>
    <li>Likely not creating a large number of value sets.</li>
</ul>

<p>All in all Value Objects can add a lot of, well, value to your code base.  <b>If</b> used properly.  They should not simply replace associative arrays.  With everything in software development there is a price and a reward.  It is up to you to determine if the rewards of the Value Object are worth the price.</p>

<blockquote><p><a href="http://www.github.com/cspray/SprayFire/">SprayFire</a> goes a slightly different route then the example code above.  The <code><a href="https://github.com/cspray/SprayFire/blob/master/libs/SprayFire/ValueObject.php">\SprayFire\ValueObject</a></code> is an abstract class that uses <code><a href="http://us2.php.net/manual/en/language.oop5.overloading.php#object.get">_get()</a></code> for access and ensures that the property is immutable by throwing an exception on <code><a href="http://us2.php.net/manual/en/language.oop5.overloading.php#object.set">__set()</a></code> and <code><a href="http://us2.php.net/manual/en/language.oop5.overloading.php#object.unset">__unset()</a></code>.  Additionally, it allows only certain properties of the object to be accessible instead of simply all of them, enforces the type of a value when the object is created, and requires a <code>toArray()</code> method be implemented that lets us still make use of those array functions.</p></blockquote>